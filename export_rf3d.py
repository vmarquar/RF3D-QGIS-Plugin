# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ExportToRF3D
                                 A QGIS plugin
 This plugin exports the prepared datasets for a RockyFor3D Simulation
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-09-25
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Valentin Marquart
        email                : valentin.marquart@tum.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction, QFileDialog
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .export_rf3d_dialog import ExportToRF3DDialog
import os.path
from shutil import copyfile
from functools import reduce
from osgeo import gdalconst
from osgeo import gdal
from .rasterize_layers import getExtentFromDEM, createRasterizedAscii, rasterizeMultiFieldVectorLayer, createDEMCopy

from qgis.gui import QgsMapLayerComboBox, QgsMessageBar
from qgis.core import QgsMapLayerProxyModel, QgsProject, QgsRasterLayer, QgsVectorLayer, QgsCoordinateReferenceSystem, QgsLayerTreeLayer, QgsRasterBandStats, QgsMessageLog, Qgis


class ExportToRF3D:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ExportToRF3D_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Create the dialog (after translation) and keep reference
        self.dlg = ExportToRF3DDialog()

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&RockyFor3D Plugin')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'ExportToRF3D')
        self.toolbar.setObjectName(u'ExportToRF3D')

        self.dlg.outputPath.clear()
        self.dlg.openFinder.clicked.connect(self.select_output_directory)

        # configure Selection boxes:

        # zwei selection boxes:
        # demSelection
        # groupSelection
        # self.wcb1 = QgsMapLayerComboBox(self.dlg)
        # self.wcb1.setFilters( QgsMapLayerProxyModel.RasterLayer )

        # self.wcb2 = QgsMapLayerComboBox(self.dlg)
        # self.wcb2.setFilters( QgsMapLayerProxyModel.VectorLayer )

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ExportToRF3D', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/export_rf3d/export.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Export vector files to rockyfor3d ascii files'),
            callback=self.run,
            parent=self.iface.mainWindow())
            
        """Import rf3d generated files and style them"""
        icon_path = ':/plugins/export_rf3d/import.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Import Files from rockyfor3D output directory'),
            callback=self.runImportRockyFor3DFiles,
            parent=self.iface.mainWindow())


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&RockyFor3D Plugin'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar


    def select_output_directory(self):
        options = QFileDialog.DontResolveSymlinks | QFileDialog.ShowDirsOnly
        output_directory = QFileDialog.getExistingDirectory(self.dlg, "Open output directory ", options=options)
        self.dlg.outputPath.setText(output_directory)


    def run(self):
        """Run method that performs all the real work"""

        # init dem selection
        rasters = [layer for layer in QgsProject.instance().mapLayers().values() if isinstance(layer, QgsRasterLayer)]
        raster_list = []
        for raster in rasters:
            raster_list.append(raster.name())
        self.dlg.demSelection.addItems(raster_list)

        # init group selection until the 3rd layer (group, subgroup and subsubgroup)
        nodes = [group for group in QgsProject.instance().layerTreeRoot().children()]
        groups = [child for child in nodes if child.nodeType() == 0]
        group_list = []
        subgroup_list = []
        subsubgroup_list = []
        for group in groups:
            group_list.append(group.name())
            if len(group.children()) > 0:
                subchilds = [subchild for subchild in group.children() if subchild.nodeType() == 0]
                for subchild in subchilds:
                    subgroup_list.append(subchild)
                    if len(subchild.children()) > 0:
                        subsubchilds = [subsubchild for subsubchild in subchild.children() if subsubchild.nodeType() == 0]
                        for subsubchild in subsubchilds:
                            subsubgroup_list.append(subsubchild)
        
        # create two list sets: 1 containing the names for populating the comboBox and 1 for keeping a reference of all groups, sub- and subsubgroups together
        subgroup_names = [subgroup_name.name() for subgroup_name in subgroup_list]
        subsubgroup_names = [subsubgroup_name.name() for subsubgroup_name in subsubgroup_list]
        group_list.extend(subgroup_names)
        group_list.extend(subsubgroup_names)
        groups.extend(subgroup_list)
        groups.extend(subsubgroup_list)

        self.dlg.groupSelection.addItems(group_list)

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            
            #1) Retrieve output directory
            output_dir = self.dlg.outputPath.text()
            if output_dir == '':
                raise ValueError("No output directory selected!")
                self.iface.messageBar().pushCritical("Export to RockyFor3D", "No output directory selected!")

            #2) get selected dem reference
            selectedDEMIndex = self.dlg.demSelection.currentIndex()
            selectedDEM = rasters[selectedDEMIndex]
            if selectedDEM == '':
                raise ValueError("No DEM has been selected!")
                self.iface.messageBar().pushCritical("Export to RockyFor3D", "No DEM has been selected!")


            #3) get cell size, coord system and extent from dem
            dem = '/Users/Valentin/Library/Mobile Documents/3L68KQB4HG~com~readdle~CommonDocuments/Documents/Ingenieur-und-Hydro/4 MASTERARBEIT/2 GIS/2 Feldvorbereitung und DGM/Raster/dgm_gesamt_1m_oGeb_9999.asc'
            dem = selectedDEM.source()

            try:
                dem_outpath = createDEMCopy(dem, os.path.join(output_dir,'dem.asc'))

            except Error as e:
                print(e)
                print("the dem could not be created! Is there already a file called dem.asc?")
                raise

            dem_data = getExtentFromDEM(dem_outpath)


            # get selected group reference
            selectedGroupIndex = self.dlg.groupSelection.currentIndex()
            selectedGroup = groups[selectedGroupIndex]
            layers_in_group = selectedGroup.findLayers()
            vector_layers_in_group = [layer.layer() for layer in layers_in_group if isinstance(layer.layer(), QgsVectorLayer)]
            
            all_outputs = []
            for vector_layer in vector_layers_in_group:
                filepath = vector_layer.source()
                attribute_names = [attribute.name for attribute in vector_layer.attributeTableConfig().columns() if len(attribute.name) > 0]
                GDT_DataTypeRocky = {'rocdensity':gdal.GDT_CInt32, 'rockdensity': gdal.GDT_CInt32, 'd1_block1': gdal.GDT_Float32, 'd1':gdal.GDT_Float32, 'd2':gdal.GDT_Float32, 'd3':gdal.GDT_Float32, 'blshape': gdal.GDT_CInt32, 'rg70':gdal.GDT_Float32, 'rg20':gdal.GDT_Float32, 'rg10':gdal.GDT_Float32, 'soiltype':gdal.GDT_CInt32, 'net_number':gdal.GDT_CInt32, 'net_energy': gdal.GDT_CInt32, 'net_height': gdal.GDT_Float32 }
                output = rasterizeMultiFieldVectorLayer(filepath, output_dir, dem_data, GDT_DataType=GDT_DataTypeRocky)
                all_outputs.extend(output)



            #4) Messages
            minimum = ['rocdensity','rockdensity','d1','d2','d3','blshape','rg70','rg20','rg10','soiltype']
            nets = ['net_number','net_energy','net_height']
            forest = ['nrtrees', 'dbhmean', 'dbhstd', 'conif_percent']

            self.iface.messageBar().pushInfo("Export to RockyFor3D", "Successfully created {} ascii files.".format(len(all_outputs)))

            if set(all_outputs).issubset(minimum):
                self.iface.messageBar().pushInfo("Export to RockyFor3D", "Found all 10 minimum output files for RockyFor3D")
            # elif set(all_outputs).issubset(minimum.extend(nets)):
            #     self.iface.messageBar().pushInfo("Export to RockyFor3D", "Found all 10 minimum output files and the 3 for nets for RockyFor3D")
            # elif set(all_outputs).issubset(minimum.extend(forest)):
            #     self.iface.messageBar().pushInfo("Export to RockyFor3D", "Found all 10 minimum output files and the 4 for forest for RockyFor3D")
            # elif set(all_outputs).issubset(minimum.extend(forest).extend(nets)):
            #     self.iface.messageBar().pushInfo("Export to RockyFor3D", "Found all 10 minimum output files and the 4 for forest and 3 for the nets for RockyFor3D")
            # else:
            #     self.iface.messageBar().pushWarning("Export to RockyFor3D", "Not enought ascii output files were generated: {}".format(all_outputs))


    def runImportRockyFor3DFiles(self):
        """Import files from a selected rockyfor3d output directory"""
        self.iface.messageBar().pushInfo("RockyFor3D Plugin:","All Stuff will be imported...")
        start_path = "/Volumes/ga84laz/MASTERARBEIT/Mod_PC/RockyFor3D/rf3d_obere-Berme_W_S_1m_bl123"
        style_directory = "/Users/Valentin/Library/Mobile Documents/3L68KQB4HG~com~readdle~CommonDocuments/Documents/Ingenieur-und-Hydro/4 MASTERARBEIT/2 GIS/4 Rockyfor3D Inputdaten/styles"
        import_files = ['E_95CI.asc', 'Ph_95CI.asc', 'Nr_deposited.asc', 'Reach_probability.asc']
        crs_number = 31468
        # or import_files = 'all'
        root = QgsProject.instance().layerTreeRoot()

        #1) Create a group to insert the imported layers into
        #from time import localtime, strftime
        #rf3d_group = root.insertGroup(0, 'RockyFor3D Import from '+strftime("%Y-%m-%d %H:%M", localtime()))
        rf3d_group = root.insertGroup(0, os.path.basename(start_path))

        #2) switch off crs prompt after import
        s = QSettings()
        oldValidation = s.value( "/Projections/defaultBehavior" )
        s.setValue( "/Projections/defaultBehavior", "useGlobal" )

        #3) walk through the directory recursevily and 3-1) create groups and subgroups, 3-2) import files, 3-3)style them 
        try:
            for root, dirs, files in os.walk(start_path, topdown=True):
                for _dir in dirs:

                    # only import *sims* directories!
                    if "sims-" in _dir:
                        relative_path = os.path.relpath(os.path.join(root, _dir),start_path)
                        relatives = relative_path.split(os.sep)

                        target_path = os.path.join(root, _dir)
                        # print("Creating following groups and subgroups: {}".format(relatives))
                        # print("Loading selected files from this folder: {}".format(target_path))
                        
                        # 3-1) create groups and subgroups
                        group = rf3d_group
                        for relative in relatives:
                            # create a group for each item
                            group = group.addGroup(relative)

                        _files = [f for f in os.listdir(target_path) if os.path.isfile(os.path.join(target_path, f))]
                        message = "Group: {}".format(reduce(os.path.join,relatives))
                        print(message)
                        QgsMessageLog.logMessage(message, tag="Plugins", level=Qgis.Info)

                        for _file in _files:
                            # filter for ascii files only:
                            if ".asc" == os.path.splitext(_file)[1]:
                                # only import files in import_files

                                if _file in import_files or import_files=='all':
                                    try:
                                        # 3-2) import files into last subgroup
                                        # 3-3) style the imported files accordingly
                                        filepath = os.path.join(target_path, _file)
                                        rName = os.path.splitext(os.path.basename(filepath))[0]
                                        style_path = os.path.join(style_directory, (rName+'.qml'))

                                        rLayer = QgsRasterLayer(filepath, rName)
                                        rLayer.setCrs( QgsCoordinateReferenceSystem(crs_number, QgsCoordinateReferenceSystem.EpsgCrsId) )
                                        try:
                                            rLayer.loadNamedStyle(style_path)
                                        except Error:
                                            print("Could not style the desired layer {}".format(rName))
                                            pass
                                        QgsProject.instance().addMapLayer(rLayer, False)
                                        group.insertChildNode(0,QgsLayerTreeLayer(rLayer))
                                        #rLayer.triggerRepaint()
                                        #self.iface.layerTreeView().refreshLayerSymbology( rLayer.id() )


                                        ### Print statistics to console! ###
                                        stats = rLayer.dataProvider().bandStatistics(1, QgsRasterBandStats.All, rLayer.extent(), 0)
                                        min = stats.minimumValue
                                        max = stats.maximumValue
                                        message = '    Layer: {} min: {:.2f}, max: {:.2f}'.format(rName, min, max)
                                        print(message)
                                        QgsMessageLog.logMessage(message, tag="Plugins", level=Qgis.Info)


                                    except Error as e:
                                        print(e)
                                        print("Could not add the following File: {}".format(_file))


                                
        except Error as e:
            print(e)


        #re-enable the crs prompt
        s.setValue( "/Projections/defaultBehavior", oldValidation )